/// strategy.rs — Signal Fusion & Trade Decision Engine
///
/// This module fuses signals from:
///   1. GARCH(1,1)   → volatility regime filter
///   2. OU Process   → mean-reversion entry/exit Z-score + P(continue)
///   3. OFI / VPIN   → directional confirmation and informed-flow gate
///   4. EV Model     → mandatory fee-adjusted Expected Value gate
///
/// Decision pipeline:
///   Step 1: GARCH regime check — avoid HIGH vol unless VPIN confirms
///   Step 2: OU Z-score entry signal (|Z| ≥ ou_entry_z)
///   Step 3: OFI direction must AGREE with OU direction (confluence)
///   Step 4: VPIN ≥ threshold (informed flow present)
///   Step 5: EV > round-trip fees (mathematical viability)
///   Step 6: Compute Kelly position size and risk levels
///
/// Exit pipeline (checked every bar):
///   E1: |Z| reverted below ou_exit_z  (OU mean-reversion complete)
///   E2: P(continuation) < exit_prob_threshold  (PDF-based exit)
///   E3: Price hits stop-loss (hard risk limit)
///   E4: Price hits take-profit (profit secured)
///   E5: Max hold duration exceeded (time-stop)

use crate::config::AppConfig;
use crate::models::{
    garch::{Garch11, VolRegime},
    ofi::{FlowAnalyser, TradeTick},
    ou_process::OuSignalEngine,
};
use crate::risk::{evaluate_ev, kelly_fraction, position_size, RiskLevels};

/// A trade signal generated by strategy fusion.
#[derive(Debug, Clone)]
pub struct TradeSignal {
    /// +1 = LONG, −1 = SHORT
    pub direction: i8,
    /// Entry price (market mid-price at signal)
    pub entry_price: f64,
    /// Fraction of equity to risk (post-Kelly)
    pub size_frac: f64,
    /// Risk level set (stop, TP)
    pub risk: RiskLevels,
    /// Z-score at entry
    pub z_score: f64,
    /// EV estimate
    pub ev: f64,
    /// VPIN at entry
    pub vpin: Option<f64>,
    /// GARCH σ (per-bar) at entry
    pub garch_sigma_bar: f64,
}

/// Exit reason for logging and analysis.
#[derive(Debug, Clone, PartialEq)]
pub enum ExitReason {
    ZScoreReverted,
    ProbabilityExit,
    StopLoss,
    TakeProfit,
    TimeStop,
    ManualClose,
}

/// Active position tracking.
#[derive(Debug, Clone)]
pub struct ActivePosition {
    pub signal:    TradeSignal,
    pub open_price: f64,
    /// Bar count since open
    pub bars_held: usize,
    /// Realised PnL on close (set when position is closed)
    pub pnl_frac: Option<f64>,
    pub exit_reason: Option<ExitReason>,
}

impl ActivePosition {
    pub fn new(signal: TradeSignal) -> Self {
        let open_price = signal.entry_price;
        Self { signal, open_price, bars_held: 0, pnl_frac: None, exit_reason: None }
    }
}

/// Core strategy engine: holds state for all quant models.
pub struct StrategyEngine {
    pub garch:  Garch11,
    pub ou:     OuSignalEngine,
    pub flow:   FlowAnalyser,
    pub cfg:    AppConfig,
    /// Current open position (None if flat)
    pub position: Option<ActivePosition>,
    /// Log of closed trades
    pub closed_trades: Vec<ActivePosition>,
    /// Current equity
    pub equity: f64,
}

impl StrategyEngine {
    pub fn new(cfg: AppConfig) -> Self {
        // bars_per_year for 1m bars: 365 * 24 * 60 = 525600
        let bars_per_year = bars_per_year(&cfg.kline_interval);

        let garch = Garch11::new(cfg.garch_omega, cfg.garch_alpha, cfg.garch_beta, bars_per_year);
        let ou    = OuSignalEngine::new(cfg.ou_window);
        let flow  = FlowAnalyser::new(
            cfg.vpin_bucket_size,
            cfg.vpin_bucket_size as f64 * 10.0, // volume per VPIN bucket
            cfg.vpin_n_buckets,
            0.30, // OFI threshold for directional signal
        );
        let equity = cfg.initial_capital;
        Self { garch, ou, flow, cfg, position: None, closed_trades: vec![], equity }
    }

    /// Process a bar (kline) and optional tick data.
    ///
    /// In backtest mode: `tick` carries bar volume split via heuristic.
    /// In live mode: call `process_tick()` per tick separately.
    ///
    /// Returns a TradeSignal if entry conditions are met.
    pub fn on_bar(
        &mut self,
        price: f64,
        log_return: f64,
        tick: &TradeTick,
    ) -> Option<TradeSignal> {
        // ── Update models ──────────────────────────────────────────────────
        self.garch.update(log_return, 0.0);
        let z = self.ou.push(price)?;  // need OU window full
        let flow_signal = self.flow.process(tick);

        // ── Check exit conditions for existing position ────────────────────
        if let Some(ref mut pos) = self.position {
            pos.bars_held += 1;
            let should_exit = self.check_exit(price, z, pos.bars_held);
            if let Some(reason) = should_exit {
                self.close_position(price, reason);
            }
        }

        // ── Only evaluate entry if flat ────────────────────────────────────
        if self.position.is_some() {
            return None;
        }

        // ── STEP 1: GARCH regime filter ───────────────────────────────────
        // In HIGH vol regime, require VPIN confirmation (informed traders active)
        let regime = self.garch.regime();
        if regime == VolRegime::High && !flow_signal.vpin_confirmed(self.cfg.vpin_threshold) {
            return None;
        }

        // ── STEP 2: OU signal ─────────────────────────────────────────────
        // |Z| ≥ ou_entry_z required
        let ou_dir = self.ou.signal(price, self.cfg.ou_entry_z);
        if ou_dir == 0 {
            return None;
        }

        // ── STEP 3: OFI directional confluence ───────────────────────────
        // OU says BUY (Z < 0, price below mean)  → need buy OFI (positive)
        // OU says SELL (Z > 0, price above mean) → need sell OFI (negative)
        // OFI direction must match ou_dir (or be neutral, which we allow weakly)
        if flow_signal.direction != 0 && flow_signal.direction != ou_dir {
            return None; // Opposing flow — skip
        }

        // ── STEP 4: VPIN minimum (informed-flow gate) ─────────────────────
        // Skip only if VPIN is available AND below threshold
        if flow_signal.vpin.map_or(false, |v| v < self.cfg.vpin_threshold * 0.5) {
            return None;
        }

        // ── STEP 5: EV constraint ─────────────────────────────────────────
        let ou_params = self.ou.params.as_ref()?;
        let ev_result = evaluate_ev(
            z,
            ou_params.sigma_ou,
            price,
            self.cfg.ou_exit_z,
            &self.cfg,
        );
        if !ev_result.is_viable {
            return None;
        }

        // ── STEP 6: Position sizing ───────────────────────────────────────
        let f_risk = kelly_fraction(
            ev_result.p_win,
            ev_result.avg_win,
            ev_result.avg_loss,
            0.25, // use quarter-Kelly for safety
            self.cfg.risk_per_trade,
        );
        if f_risk < 1e-6 {
            return None;
        }

        // Take-profit = OU equilibrium μ (price will revert there)
        let tp_price = if ou_dir == 1 {
            // LONG: TP above entry at μ (minus exit_z buffer)
            ou_params.mu - self.cfg.ou_exit_z * ou_params.sigma_ou
        } else {
            // SHORT: TP below entry at μ (plus exit_z buffer)
            ou_params.mu + self.cfg.ou_exit_z * ou_params.sigma_ou
        };

        let risk = if ou_dir == 1 {
            RiskLevels::long(price, self.cfg.stop_loss_frac, tp_price.max(price * 1.0001))
        } else {
            RiskLevels::short(price, self.cfg.stop_loss_frac, tp_price.min(price * 0.9999))
        };

        tracing::debug!(
            "SIGNAL: dir={} Z={:.3} EV={:.5} P_win={:.3} f_risk={:.4} VPIN={:.3}",
            ou_dir, z, ev_result.ev, ev_result.p_win, f_risk,
            flow_signal.vpin.unwrap_or(0.0)
        );

        Some(TradeSignal {
            direction:       ou_dir,
            entry_price:     price,
            size_frac:       f_risk,
            risk,
            z_score:         z,
            ev:              ev_result.ev,
            vpin:            flow_signal.vpin,
            garch_sigma_bar: self.garch.sigma_bar(),
        })
    }

    /// Open a position from a signal.
    pub fn open_position(&mut self, signal: TradeSignal) {
        self.position = Some(ActivePosition::new(signal));
    }

    /// Check whether current position should be closed.
    /// Returns Some(ExitReason) if exit is warranted.
    pub fn check_exit(
        &self,
        price: f64,
        z: f64,
        bars_held: usize,
    ) -> Option<ExitReason> {
        let pos = self.position.as_ref()?;
        let risk = &pos.signal.risk;

        // E3: Stop-loss
        if risk.is_stopped(price) {
            return Some(ExitReason::StopLoss);
        }

        // E4: Take-profit
        if risk.is_profit_taken(price) {
            return Some(ExitReason::TakeProfit);
        }

        // E5: Time-stop
        if bars_held >= self.cfg.max_hold_bars {
            return Some(ExitReason::TimeStop);
        }

        // E1: Z-score reverted
        if z.abs() < self.cfg.ou_exit_z {
            return Some(ExitReason::ZScoreReverted);
        }

        // E2: PDF probability exit
        if let Some(p_cont) = self.ou.p_continuation(price) {
            if p_cont < self.cfg.exit_prob_threshold {
                return Some(ExitReason::ProbabilityExit);
            }
        }

        None
    }

    /// Close current position, calculate PnL, update equity.
    pub fn close_position(&mut self, exit_price: f64, reason: ExitReason) {
        if let Some(mut pos) = self.position.take() {
            let (_, net_pnl_frac) = crate::risk::calculate_pnl(
                pos.signal.entry_price,
                exit_price,
                &self.cfg,
            );
            let dir = pos.signal.direction as f64;
            let pnl_frac = net_pnl_frac * dir;
            let dollar_pnl = self.equity * pos.signal.size_frac * pnl_frac
                * self.cfg.max_leverage as f64;

            self.equity += dollar_pnl;
            pos.pnl_frac    = Some(pnl_frac);
            pos.exit_reason = Some(reason);

            tracing::info!(
                "CLOSE: dir={} entry={:.2} exit={:.2} PnL={:.4}% equity={:.2}",
                pos.signal.direction,
                pos.signal.entry_price,
                exit_price,
                pnl_frac * 100.0,
                self.equity
            );

            self.closed_trades.push(pos);
        }
    }
}

// ── Helpers ──────────────────────────────────────────────────────────────

fn bars_per_year(interval: &str) -> f64 {
    match interval {
        "1m"  => 365.0 * 24.0 * 60.0,
        "3m"  => 365.0 * 24.0 * 20.0,
        "5m"  => 365.0 * 24.0 * 12.0,
        "15m" => 365.0 * 24.0 * 4.0,
        "30m" => 365.0 * 24.0 * 2.0,
        "1h"  => 365.0 * 24.0,
        "4h"  => 365.0 * 6.0,
        "1d"  => 365.0,
        _     => 365.0 * 24.0 * 60.0, // default: 1m
    }
}
